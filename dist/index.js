#!/usr/bin/env node
import bt from"cac";import{join as tt}from"node:path";import I from"picocolors";import{log as F,text as et,note as rt,intro as ot,outro as O,group as it,select as z,cancel as at,spinner as nt}from"@clack/prompts";import m from"node:path";import{stat as W,readdir as Z,mkdir as q,copyFile as G,readFile as H,writeFile as K}from"fs/promises";import M from"fast-glob";var b=async t=>{let e=await W(t).catch(r=>null);return e?.isFile()||e?.isDirectory()},D=async t=>(await Z(t,{withFileTypes:!0})).filter(r=>!r.name.startsWith(".")&&r.isDirectory()),Q=t=>t,A=async(t,e,{cwd:r,rename:i=Q,parents:s=!0}={})=>{let o=typeof t=="string"?[t]:t;if(o.length===0||!e)throw new TypeError("`src` and `dest` are required");let c=await M(o,{cwd:r,dot:!0,absolute:!1,stats:!1}),l=r?m.resolve(r,e):e;return Promise.all(c.map(async a=>{let u=m.dirname(a),p=i(m.basename(a)),w=r?m.resolve(r,a):a,f=s?m.join(l,u,p):m.join(l,p);return await q(m.dirname(f),{recursive:!0}),G(w,f)}))},h=async t=>{if(!await b(t))throw new Error(`Cannot find ${t}`);try{let r=await H(t,"utf-8");return JSON.parse(r)}catch(r){throw new Error(`Cannot read ${t}: ${r?.message}`)}},S=async(t,e)=>{try{await K(t,JSON.stringify(e,null,2))}catch(r){throw new Error(`Cannot write ${t}: ${r?.message}`)}},E=async(t,e)=>{let r=e(await h(t));await S(t,r)};import{homedir as X}from"node:os";var d=`${X()}/.wid`,g=`${d}/boilerplates`,v=`${d}/boilerplates.json`,B="https://github.com/zhaohuanyuu/wid-templates.git";var $=async()=>{try{return await h(`${d}/config.json`)}catch{return{}}};import Y from"validate-npm-package-name";function C(t){let e=Y(t);return e.validForNewPackages?{valid:!0}:{valid:!1,problems:[...e.errors||[],...e.warnings||[]]}}var R=async(t,e)=>{ot(I.bgCyan(" wid new project ")),t||(t=await et({message:"what is the name of your project?",placeholder:"your project name",validate(r){if(r.length<=0)return"project name is required!"}}),console.log(I.magenta(t)));try{let{valid:r,problems:i}=C(t);if(!r){i?.forEach(n=>F.error(I.red(n))),O("new project failed!");return}let s=await h(v),o=await it({category:()=>z({message:"select a project category",options:s.map(n=>({value:n.name,label:n.name}))}),template:({results:n})=>{let x=n.category,J=s.find(j=>j.name===x).children;return J.length?z({message:"select a project template",options:J.map(j=>({value:j.name,label:j.name}))}):at(`cannot find the boilerplate under ${I.bold(x)}/`)}},{onCancel:({results:n})=>{let x=Object.keys(n).join(", ");O(`${x} operation cancelled!`),process.exit(0)}}),c=nt(),l=["**"],{category:a,template:u}=o,p=tt(process.cwd(),`/${t}`),w=await b(p),{boilerplateDir:f=g}=await $();if(c.start("project boilerplate generating..."),w){F.error(`folder ${t} had already been existed!`),c.stop(`new project ${t} failed`);return}await A(l,p,{parents:!0,cwd:`${f}/${a}/${u}`}),await E(`${p}/package.json`,n=>({...n,name:t})),c.stop("project boilerplate generate completed");let U=`cd   ${t}
pnpm install
pnpm dev`;rt(U,"then you can"),O(`new project ${t} complete`)}catch(r){O(r?.toString())}};import{writeFile as st}from"node:fs/promises";import T from"picocolors";import{simpleGit as ct}from"simple-git";import{intro as pt,outro as L,spinner as lt,log as N}from"@clack/prompts";var y=async t=>{let e=lt(),r=ct(),i=t?"re":"",{repoUrl:s=B,boilerplateDir:o=g}=await $();pt(T.bgCyan(` wid ${i}initializing `));try{if(await b(o)){N.info("project boilerplates already downloaded"),N.success(`you can access at: ${T.underline(o)}`),L(`wid has been ${i}initialized`);return}e.start("project boilerplates downloading..."),await r.clone(s,o,["--depth=1"]),e.stop("project boilerplates already downloaded"),N.success(`you can access at: ${T.underline(o)}`);let l=await D(o),a=await Promise.all(l.map(async u=>{let p=u.name,w=await D(u.path+"/"+p);return{name:p,children:w.map(f=>({name:f.name}))}}));await st(v,JSON.stringify(a,null,2)),L(`wid has been ${i}initialized`)}catch(c){L(c?.toString())}};import{log as mt}from"@clack/prompts";var P=async t=>{let{repo:e,reset:r}=t,i=`${d}/config.json`;if(e){let s=/^https:\/\/github\.com\/([a-zA-Z\d_-]+)\/([a-zA-Z\d_-]+)(\.git)?$/,o=/^git@github\.com:([a-zA-Z\d_-]+)\/([a-zA-Z\d_-]+)(\.git)?$/;if(!(s.test(e)||o.test(e))){mt.error("It's not a valid github repository url!");return}let l=/\/([^/]+)\.git$/,[,a=""]=e.match(l);await S(i,{repoUrl:e,boilerplateDir:`${d}/${a}`}),await y(!0)}r&&(await E(i,s=>({})),await y(!0))};import dt from"picocolors";import{simpleGit as ut}from"simple-git";import{intro as ft,outro as gt,spinner as yt}from"@clack/prompts";var _=async()=>{let t=ut(g);ft(dt.bgCyan("wid update"));try{let e=yt();e.start("update project boilerplates..."),await t.pull(),e.stop("wid has been updated")}catch(e){gt(e?.toString())}};var V="0.1.8";var k=bt("wid");k.command("[..files]","default command: init\u3001update").option("--repo [repo url]","set a custom repository url").action((t,e)=>{switch(t){case"init":y();break;case"set":P(e);break;case"reset":P({"--":[],reset:!0});break;case"update":_();break;default:return null}});k.command("new [name]","create project based on a specified boilerplate").option("--path [path]","path corresponding to the project boilerplate").example("--path monorepo/turbo").action(R);k.help().version(V).parse();
//# sourceMappingURL=index.js.map